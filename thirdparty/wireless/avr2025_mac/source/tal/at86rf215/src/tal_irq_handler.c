/**
 * @file tal_irq_handler.c
 *
 * @brief This file handles the interrupts generated by the transceiver.
 *
 * Copyright (C) 2013 Atmel Corporation. All rights reserved.
 *
 * \asf_license_start
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. The name of Atmel may not be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * 4. This software may only be redistributed and used in connection with an
 *    Atmel microcontroller product.
 *
 * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
 * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * \asf_license_stop
 *
 *
 */

/*
 * Copyright (c) 2013, Atmel Corporation All rights reserved.
 *
 * Licensed under Atmel's Limited License Agreement --> EULA.txt
 */

/* === INCLUDES ============================================================ */

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include "pal.h"
#include "tal_config.h"
#include "tal_internal.h"



/* === TYPES =============================================================== */

/* === MACROS ============================================================== */

/* === GLOBALS ============================================================= */

/* === PROTOTYPES ========================================================== */

/* === IMPLEMENTATION ====================================================== */


/**
 * @brief Transceiver interrupt handler
 *
 * This function handles the transceiver interrupt. It reads all IRQs from the
 * transceivers and stores them to a variable. If a transceiver is currently
 * sleeping, then the IRQs are not handled.
 * The actual processing of the IRQs is triggered from tal_task().
 */
void trx_irq_handler_cb(void)
{
    //debug_text(PSTR("trx_irq_handler_cb()"));

    /* Get all IRQS values */
    uint8_t irqs_array[4];

    
        pal_trx_read(RG_RF09_IRQS, irqs_array, 4);
    

    
        /* Handle BB IRQS */
        for (uint8_t trx_id = 0; trx_id < 2; trx_id++)
        {
            if (tal_state[trx_id] == TAL_SLEEP)
            {
                continue;
            }

            uint8_t irqs = irqs_array[trx_id + 2];

            if (irqs != BB_IRQ_NO_IRQ)
            {
                //debug_text_val(PSTR("INFO: ISR for BB "), trx_id);
                //debug_text_val(PSTR("INFO: IRQ-flag-vector of RG_BBCx_IRQS ="), irqs);

                if (irqs & BB_IRQ_RXEM)
                {
                    //debug_text(PSTR("IRQ - BB_IRQ_RXEM"));
                    irqs &= (uint8_t)(~((uint32_t)BB_IRQ_RXEM)); // avoid Pa091
                }
                if (irqs & BB_IRQ_RXAM)
                {
                    //debug_text(PSTR("IRQ - BB_IRQ_RXAM"));
                    irqs &= (uint8_t)(~((uint32_t)BB_IRQ_RXAM)); // avoid Pa091
                }
                if (irqs & BB_IRQ_AGCR)
                {
                    //debug_text(PSTR("IRQ - BB_IRQ_AGCR"));
                    irqs &= (uint8_t)(~((uint32_t)BB_IRQ_AGCR)); // avoid Pa091
                }
                if (irqs & BB_IRQ_AGCH)
                {
                    //debug_text(PSTR("IRQ - BB_IRQ_AGCH"));
                    irqs &= (uint8_t)(~((uint32_t)BB_IRQ_AGCH)); // avoid Pa091
                }
                if (irqs & BB_IRQ_RXFS)
                {
                    //debug_text(PSTR("IRQ - BB_IRQ_RXFS"));
#ifdef ENABLE_TSTAMP
                    pal_get_current_time(&fs_tstamp[trx_id]);
#endif
                    irqs &= (uint8_t)(~((uint32_t)BB_IRQ_RXFS)); // avoid Pa091
                }
                if (irqs & BB_IRQ_RXFE)
                {
                    //debug_text(PSTR("IRQ - BB_IRQ_RXFE"));
                    pal_get_current_time(&rxe_txe_tstamp[trx_id]);
                }
                if (irqs & BB_IRQ_TXFE)
                {
                    //debug_text(PSTR("IRQ - BB_IRQ_TXFE"));
                    /* used for IFS and for MEASURE_ON_AIR_DURATION */
                    pal_get_current_time(&rxe_txe_tstamp[trx_id]);
                }

                /*
                 * Store remaining flags to global TAL variable and
                 * handle them within tal_task()
                 */
                tal_bb_irqs[trx_id] |= irqs;
            }
        }
    

    /* Handle RF IRQS */
    for (uint8_t trx_id = 0; trx_id < 2; trx_id++)
    {
        if (tal_state[trx_id] == TAL_SLEEP)
        {
            continue;
        }

        uint8_t irqs = irqs_array[trx_id];

        if (irqs != RF_IRQ_NO_IRQ)
        {
            //debug_text_val(PSTR("INFO: ISR for RF "), trx_id);
            //debug_text_val(PSTR("INFO: IRQ-flag-vector of RG_RFxx_IRQS ="), irqs);

            if (irqs & RF_IRQ_TRXRDY)
            {
                //debug_text(PSTR("IRQ - RF_IRQ_TRXRDY"));
            }
            if (irqs & RF_IRQ_TRXERR)
            {
                //debug_text(PSTR("IRQ - RF_IRQ_TRXERR"));
            }
            if (irqs & RF_IRQ_BATLOW)
            {
                //debug_text(PSTR("IRQ - RF_IRQ_BATLOW"));
            }
            if (irqs & RF_IRQ_WAKEUP)
            {
                //debug_text(PSTR("IRQ - RF_IRQ_WAKEUP"));
            }
            if (irqs & RF_IRQ_IQIFSF)
            {
                //debug_text(PSTR("IRQ - RF_IRQ_IQIFSF"));
            }
            if (irqs & RF_IRQ_EDC)
            {

                //debug_text(PSTR("IRQ - RF_IRQ_EDC"));
            }
            tal_rf_irqs[trx_id] |= irqs;
        }
    }
}/* trx_irq_handler_cb() */



/* EOF */
